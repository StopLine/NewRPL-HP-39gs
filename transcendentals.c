#include "newrpl.h"

/* Transcendental functions with variable precision implementing a decimal variant of the CORDIC
 * method, as published on the paper:
 * "Computation of Decimal Transcendental Functions Using the CORDIC Algorithm"
 * By Alvaro Vazquez, Julio Villalba and Elisardo Antelo
 *
 * The implementation was done from scratch by the newRPL Team.
 *
 */

static const uint32_t const Constant_K1[]={
    827473885, 753612509, 239673272, 118874537, 694588640, 625545610, 881793292, 113562984, 91259484, 230937158,
    400060219, 827060572, 721102804, 486344264, 463790215, 735654010, 4987151, 497333117, 312083712, 463838785,
    714068872, 998370249, 354780836, 312328991, 905654355, 388842081, 894921916, 687310274, 677758246, 171280224,
    782226129, 803505605, 386356807, 406160126, 957609851, 833717873, 1801105, 249211992, 197047270, 758796940,
    4835709, 684937987, 907448142, 718373743, 130476739, 600004102, 819201457, 835559756, 716617934, 262207155,
    594385860, 163144638, 744290461, 468744640, 42157595, 291918391, 989024677, 661963129, 425298182, 830152904,
    733120665, 404604096, 512331111, 703906448, 469930820, 939911922, 315676856, 327236888, 2001595, 965535305,
    638752873, 356837330, 418580092, 56237934, 997561401, 185894506, 897905203, 566495201, 642311881, 938083484,
    712607400, 369577267, 775321449, 501599704, 767713367, 50078181, 868411794, 397181389, 463494605, 635572109,
    300353131, 123582969, 421550519, 13374362, 316550339, 103531847, 103356546, 985131703, 481107608, 594508769,
    677169612, 884140761, 471029983, 736377948, 634001438, 650088892, 985365475, 801958891, 231059013, 412680655,
    192670550, 805928099, 837693749, 262944770, 38368262, 97030251, 814675165, 960942471, 60705365, 943462938,
    726727916, 153805408, 662373400, 635659948, 618964592, 737191963, 752805170, 802561316, 348704400, 770560374,
    661183232, 445878085, 348506522, 975994134, 547013515, 559229056, 820181667, 158270321, 163852659, 629087692,
    980053141, 856336377, 888856677, 485394654, 440874568, 331345205, 254926745, 394961446, 938879580, 339955819,
    380010584, 156897721, 157353518, 262114631, 598257082, 901300182, 674046118, 358147591, 476879119, 75327620,
    184849342, 236753346, 409986306, 375505174, 482025831, 881927979, 745531183, 742768893, 580299026, 92254270,
    503259025, 904149977, 223823586, 866272606, 737385197, 664660292, 200006549, 889211560, 109632277, 743561252,
    705389323, 466308213, 953347086, 759292200, 999806561, 231417372, 602853993, 830388226, 727127714, 556156255,
    344207771, 431859149, 800428751, 771830518, 38303899, 358505767, 436082978, 808641148, 106539360, 824933627,
    994201930, 347808008, 300154053, 993938936, 766534037, 578627177, 497163413, 221738651, 267764056, 255019083,
    899236998, 409311384, 793751052, 812655186, 471393610, 483097298, 193802965, 591557413, 929553457, 123154626,
    683484298, 610399448, 310381933, 604075086
};

static const uint32_t const Constant_Kh1[]={
    482332925, 430056032, 441988713, 713211954, 836042163, 188213043, 494545234, 748087198, 24929339, 520079638,
    811619231, 622520283, 842938966, 433685748, 248946147, 124841373, 981672304, 632147811, 207137206, 814671165,
    312940069, 582435597, 901329007, 606962023, 269571106, 966712306, 135443811, 1782762, 137869094, 10629396,
    915234209, 905929519, 625300595, 781406517, 329675669, 9682673, 317714080, 584993361, 711157623, 935614037,
    713041800, 152721955, 550575355, 552076592, 466060741, 820100649, 576687385, 696229343, 930611173, 344911587,
    508646546, 722690576, 961230926, 146621404, 597629172, 447131758, 197173387, 29196382, 933615739, 174550316,
    390560660, 507220594, 932968538, 389823358, 654586389, 93921025, 321135473, 972535793, 238987939, 672590731,
    670694562, 563549519, 2363153, 603115497, 657267492, 124978009, 306183867, 478987917, 899756953, 803419823,
    748174890, 253923169, 408322488, 363456873, 921373054, 692579132, 450807415, 639147566, 319364142, 717615104,
    406844992, 195057529, 347731745, 492613005, 26507620, 771026219, 240699112, 592631498, 11871838, 834871050,
    334572244, 716072856, 207574839, 340348529, 332250769, 396200323, 559298099, 999869945, 555650072, 25727216,
    438573631, 766650464, 720670293, 699018624, 763061867, 249571248, 438997177, 794207689, 9834768, 561390909,
    507465122, 951990533, 939544349, 303933575, 740744952, 790862925, 242337420, 377396203, 286174664, 109632462,
    351066801, 222784582, 446885132, 779327662, 994801293, 599291918, 763081918, 700217039, 68060162, 522628394,
    888055384, 452250569, 226368181, 964929075, 5891842, 700903257, 244722792, 828255415, 894890560, 107189444,
    958375958, 521529358, 279436069, 716424119, 522798849, 363353202, 689734021, 776494476, 321651648, 82617866,
    412682055, 211875173, 79864465, 554336759, 650447169, 816886170, 135795228, 296920630, 250860794, 786188140,
    955390828, 843449362, 648473718, 675055421, 132299839, 740552927, 249239496, 411548741, 378944865, 229780973,
    737125933, 458509026, 432126169, 59608483, 254500201, 578010549, 269496293, 79229336, 196118844, 279535656,
    40438205, 298946044, 445746922, 860560988, 902571761, 498671550, 580221735, 574075998, 964159545, 413150541,
    178982844, 536955338, 307196210, 254669808, 43263973, 734579612, 350494879, 831679567, 740209989, 112816628,
    192551598, 265569814, 588876492, 557008490, 454392732, 844451461, 566061065, 667895944, 370611062, 110045400,
    74141456, 815089240, 136894939, 121095223
};



static const uint32_t const Constant_2PI[]={
815790254, 19893152, 95605518, 199162678, 173166529, 792482778, 552931514, 383457493, 191272874, 742757392, 989009424, 724407838, 261348855, 442132237, 393057004, 389120848, 825697725, 596979216, 41023478, 12845025, 272190136, 190776757, 336290820, 765593595, 217156876, 446558357, 360997725, 920330693, 534358098, 50851377, 436854510, 419843844, 713897112, 372503796, 909552483, 478828666, 704664781, 369893687, 426695148, 231470510, 709632272, 288394713, 954470028, 434643442, 229049838, 329412003, 558760016, 578195554, 683514934, 572510363, 485308505, 713273961, 366959550, 99823976, 47296133, 440551192, 233068997, 860591064, 442159501, 399138185, 917717385, 967701098, 911141349, 57236594, 917263006, 328243984, 201868344, 470956327, 984559356, 854520853, 652782839, 49499294, 7117528, 250676486, 630038702, 204811607, 432411393, 830420950, 735405797, 898258662, 336851813, 929241609, 420809506, 954945369, 889651075, 353567489, 119239789, 36388591, 532020942, 320712741, 802571672, 801969764, 540334227, 12080185, 987863851, 350927492, 815019676, 345571177, 906623372, 139190165, 448490830, 303114971, 56695826, 249944355, 519882778, 799154724, 60370593, 60390407, 365593646, 187230676, 172655773, 440213097, 787619051, 843284039, 322239181, 600385575, 245361322, 556106434, 391556371, 757518750, 572776470, 746231912, 85751093, 719650698, 533829460, 284123435, 506641676, 750577317, 627567, 237634202, 7052386, 650668937, 528504461, 69381660, 4891891, 219263719, 946346563, 609990211, 999674595, 442269999, 992103741, 954954261, 631962725, 172806883, 425804392, 403991222, 851784708, 158455937, 917074210, 686029309, 180244990, 744293688, 834727435, 551557921, 557154268, 52712165, 113625429, 881026400, 963693533, 350476934, 435258635, 554107843, 972188740, 438140435, 279044947, 204278989, 131328617, 734672488, 389825966, 587636602, 544978245, 470377150, 992549913, 614892475, 621023709, 386522358, 437223476, 918390618, 454073151, 321886611, 390388302, 304276829, 109764093, 2266106, 578518072, 343072873, 565850818, 304184192, 117634976, 401321263, 254744917, 452049828, 642678721, 90865329, 692069722, 129713384, 240381829, 356633054, 129646757, 689225695, 195133186, 392885762, 790986076, 928924589, 704221111, 820540387, 223490056, 881625696, 446345071, 921910116, 329418768, 302656461, 596429617, 68423413, 725606965, 257241799, 461563281, 194988918, 875021164, 839433879, 655900576, 692528676, 717958647, 628318530
};
static const uint32_t const Constant_PI[]={
407895127, 9946576, 47802759, 599581339, 86583264, 396241389, 776465757, 191728746, 95636437, 371378696, 494504712, 862203919, 630674427, 221066118, 196528502, 694560424, 412848862, 298489608, 520511739, 6422512, 636095068, 95388378, 668145410, 382796797, 608578438, 723279178, 680498862, 460165346, 767179049, 25425688, 218427255, 209921922, 356948556, 686251898, 454776241, 739414333, 852332390, 184946843, 213347574, 115735255, 854816136, 144197356, 477235014, 217321721, 614524919, 164706001, 279380008, 289097777, 841757467, 786255181, 742654252, 356636980, 183479775, 549911988, 23648066, 720275596, 116534498, 930295532, 721079750, 699569092, 458858692, 983850549, 455570674, 28618297, 458631503, 164121992, 600934172, 235478163, 992279678, 927260426, 326391419, 24749647, 3558764, 125338243, 815019351, 602405803, 216205696, 915210475, 367702898, 949129331, 668425906, 464620804, 710404753, 977472684, 944825537, 676783744, 559619894, 18194295, 766010471, 160356370, 401285836, 900984882, 770167113, 506040092, 493931925, 175463746, 907509838, 172785588, 953311686, 69595082, 724245415, 151557485, 528347913, 124972177, 259941389, 899577362, 530185296, 30195203, 182796823, 593615338, 586327886, 720106548, 893809525, 921642019, 661119590, 300192787, 122680661, 778053217, 195778185, 378759375, 286388235, 873115956, 42875546, 359825349, 766914730, 142061717, 753320838, 875288658, 313783, 118817101, 503526193, 825334468, 264252230, 534690830, 502445945, 609631859, 973173281, 804995105, 999837297, 721134999, 996051870, 977477130, 815981362, 86403441, 212902196, 201995611, 925892354, 79227968, 958537105, 343014654, 90122495, 872146844, 917363717, 275778960, 778577134, 526356082, 56812714, 940513200, 481846766, 675238467, 717629317, 277053921, 986094370, 719070217, 639522473, 602139494, 65664308, 367336244, 194912983, 793818301, 272489122, 735188575, 996274956, 807446237, 310511854, 193261179, 218611738, 959195309, 727036575, 160943305, 695194151, 652138414, 54882046, 1133053, 789259036, 171536436, 282925409, 152092096, 558817488, 700660631, 127372458, 726024914, 821339360, 45432664, 346034861, 564856692, 120190914, 678316527, 564823378, 344612847, 97566593, 196442881, 895493038, 964462294, 852110555, 410270193, 111745028, 940812848, 223172535, 460955058, 664709384, 651328230, 798214808, 534211706, 862803482, 628620899, 230781640, 97494459, 937510582, 419716939, 327950288, 846264338, 358979323, 314159265
};
static const uint32_t const Constant_PI_2[]={
203947563, 504973288, 523901379, 299790669, 543291632, 698120694, 388232878, 595864373, 47818218, 185689348, 747252356, 931101959, 315337213, 110533059, 98264251, 347280212, 206424431, 649244804, 260255869, 3211256, 318047534, 47694189, 834072705, 191398398, 304289219, 361639589, 340249431, 730082673, 383589524, 512712844, 109213627, 104960961, 178474278, 843125949, 727388120, 369707166, 926166195, 92473421, 606673787, 57867627, 427408068, 72098678, 738617507, 608660860, 807262459, 82353000, 639690004, 644548888, 920878733, 393127590, 371327126, 678318490, 91739887, 274955994, 11824033, 360137798, 58267249, 465147766, 360539875, 349784546, 729429346, 491925274, 727785337, 514309148, 229315751, 82060996, 800467086, 117739081, 496139839, 963630213, 663195709, 12374823, 501779382, 562669121, 907509675, 301202901, 608102848, 457605237, 683851449, 474564665, 334212953, 732310402, 355202376, 988736342, 472412768, 338391872, 779809947, 509097147, 383005235, 80178185, 200642918, 950492441, 385083556, 753020046, 246965962, 87731873, 453754919, 86392794, 476655843, 534797541, 862122707, 575778742, 764173956, 562486088, 129970694, 449788681, 765092648, 515097601, 91398411, 296807669, 293163943, 860053274, 946904762, 460821009, 830559795, 650096393, 561340330, 889026608, 597889092, 689379687, 143194117, 436557978, 521437773, 179912674, 883457365, 71030858, 376660419, 937644329, 500156891, 559408550, 251763096, 412667234, 132126115, 767345415, 751222972, 804815929, 986586640, 902497552, 999918648, 360567499, 498025935, 488738565, 907990681, 43201720, 606451098, 100997805, 462946177, 539613984, 479268552, 671507327, 45061247, 936073422, 458681858, 137889480, 389288567, 263178041, 28406357, 470256600, 740923383, 837619233, 858814658, 138526960, 993047185, 859535108, 319761236, 301069747, 32832154, 683668122, 597456491, 396909150, 636244561, 367594287, 998137478, 403723118, 655255927, 96630589, 609305869, 979597654, 863518287, 580471652, 347597075, 326069207, 527441023, 566526, 394629518, 585768218, 141462704, 76046048, 779408744, 350330315, 63686229, 363012457, 410669680, 522716332, 173017430, 282428346, 560095457, 339158263, 782411689, 672306423, 548783296, 98221440, 447746519, 982231147, 926055277, 205135096, 55872514, 970406424, 111586267, 230477529, 332354692, 325664115, 399107404, 267105853, 931401741, 314310449, 615390820, 48747229, 968755291, 209858469, 163975144, 923132169, 679489661, 157079632
};
static const uint32_t const Constant_PI_4[]={
19737817, 524866441, 619506897, 498953347, 716458161, 490603472, 941164393, 979321866, 239091092, 928446740, 736261780, 655509798, 576686069, 552665296, 491321255, 736401060, 32122156, 246224021, 301279348, 16056281, 590237670, 238470946, 170363525, 956991994, 521446095, 808197946, 701247156, 650413366, 917947623, 563564221, 546068137, 524804805, 892371390, 215629745, 636940604, 848535833, 630830976, 462367109, 33368935, 289338138, 137040340, 360493392, 693087535, 43304303, 36312298, 411765004, 198450020, 222744443, 604393668, 965637954, 856635631, 391592451, 458699438, 374779970, 59120166, 800688990, 291336246, 325738830, 802699377, 748922731, 647146731, 459626373, 638926687, 571545743, 146578757, 410304981, 2335430, 588695409, 480699195, 818151067, 315978549, 61874118, 508896910, 813345607, 537548377, 506014509, 40514241, 288026188, 419257247, 372823328, 671064767, 661552011, 776011883, 943681711, 362063844, 691959362, 899049736, 545485738, 915026177, 400890926, 3214590, 752462206, 925417784, 765100231, 234829813, 438659366, 268774595, 431963972, 383279215, 673987707, 310613537, 878893714, 820869782, 812430443, 649853472, 248943405, 825463242, 575488008, 456992057, 484038345, 465819716, 300266371, 734523814, 304105049, 152798977, 250481969, 806701653, 445133042, 989445464, 446898437, 715970588, 182789890, 607188867, 899563372, 417286825, 355154294, 883302095, 688221646, 500784459, 797042752, 258815482, 63336171, 660630577, 836727075, 756114863, 24079648, 932933204, 512487764, 999593244, 802837499, 490129676, 443692827, 539953407, 216008604, 32255490, 504989028, 314730885, 698069922, 396342762, 357536637, 225306238, 680367110, 293409294, 689447402, 946442835, 315890206, 142031786, 351283000, 704616917, 188096168, 294073294, 692634804, 965235925, 297675544, 598806184, 505348736, 164160771, 418340610, 987282458, 984545752, 181222806, 837971438, 990687391, 18615594, 276279637, 483152948, 46529345, 897988273, 317591439, 902358264, 737985377, 630346036, 637205116, 2832632, 973147590, 928841091, 707313522, 380230240, 897043720, 751651578, 318431146, 815062285, 53348401, 613581662, 865087152, 412141730, 800477286, 695791317, 912058446, 361532118, 743916483, 491107202, 238732595, 911155737, 630276389, 25675484, 279362571, 852032120, 557931339, 152387645, 661773461, 628320576, 995537021, 335529266, 657008706, 571552249, 76954101, 243736148, 843776455, 49292349, 819875721, 615660845, 397448309, 785398163
};


// PUT THE CONSTANTS 2*PI,PI, PI/2 AND PI/4 RESPECTIVELY ON AN mpd_t THAT HAS ***NO MEMORY*** ALLOCATED TO IT
// DO NOT USE WITH RREG REGISTERS

void trig_2PI(mpd_t *real)
{
    real->alloc=224;
    real->data=Constant_2PI;
    real->digits=2016;
    real->exp=-2015;
    real->flags=MPD_CONST_DATA;
    real->len=224;
}
void trig_PI(mpd_t *real)
{
    real->alloc=224;
    real->data=Constant_PI;
    real->digits=2016;
    real->exp=-2015;
    real->flags=MPD_CONST_DATA;
    real->len=224;
}
void trig_PI_2(mpd_t *real)
{
    real->alloc=224;
    real->data=Constant_PI_2;
    real->digits=2016;
    real->exp=-2015;
    real->flags=MPD_CONST_DATA;
    real->len=224;
}
void trig_PI_4(mpd_t *real)
{
    real->alloc=224;
    real->data=Constant_PI_4;
    real->digits=2016;
    real->exp=-2016;
    real->flags=MPD_CONST_DATA;
    real->len=224;
}



// TRANSCENDENTAL FUNCTIONS TABLES
extern uint32_t atan_1_dict[];
extern uint16_t atan_1_offsets[];
extern uint8_t  atan_1_stream[];

extern uint32_t atan_2_dict[];
extern uint16_t atan_2_offsets[];
extern uint8_t  atan_2_stream[];

extern uint32_t atan_5_dict[];
extern uint16_t atan_5_offsets[];
extern uint8_t  atan_5_stream[];

extern uint32_t atanh_1_dict[];
extern uint16_t atanh_1_offsets[];
extern uint8_t  atanh_1_stream[];

extern uint32_t atanh_2_dict[];
extern uint16_t atanh_2_offsets[];
extern uint8_t  atanh_2_stream[];

extern uint32_t atanh_5_dict[];
extern uint16_t atanh_5_offsets[];
extern uint8_t  atanh_5_stream[];


// EXTRACT A NUMBER FROM A COMPRESSED STREAM

static void decompress_number(uint8_t *stream, uint32_t *dictionary, uint32_t *data, uint32_t *enddata)
{
    int _index, repeat,len,len2,idx;

    // 1-byte w/LOWER 4-BITS = MATCH LENGTH-1 (1-16 WORDS)
    // UPPER 4-BITS = REPEAT COUNT-1 (1-16 TIMES)
    // 2-BYTES = OFFSET INTO DICTIONARY
    // IF REPEAT COUNT==15 --> MORE REPEAT BYTES FOLLOWS
    // IF MATCH LENGTH==15 --> MORE MATCH LENGTH FOLLOWS


    while(data<enddata) {
        len=*stream;
        ++stream;
        _index=*stream|(stream[1]<<8);
        stream+=2;

        if(len>>4==0xf) repeat=*stream++;
        else repeat=len>>4;
        if((len&0xf)==0xf) len=*stream++;
        else len&=0xf;

        while(repeat-->=0) {
            len2=len;
            idx=_index;
            while(len2-->=0) *data++=dictionary[idx++];
        }
    }
}


// RETURN ATAN(1*10^-exponent) IN real.
// REAL MUST HAVE MINIMUM (REAL_PRECISION_MAX/9) WORDS OF data PREALLOCATED

// THIS FUNCTION RELIES ON TABLES BEING GENERATED FOR THE SAME REAL_PRECISION_MAX NUMBER OF DIGITS

static void atan_1_table(int exponent,mpd_t *real)
{

    // WARNING: 0<=exponent<= digits, THIS FUNCTION DOES NOT CHECK FOR ARGUMENT RANGE

    if(exponent>=REAL_PRECISION_MAX/2) {
        real->exp=-exponent;
        real->data[0]=1;
        real->len=1;
        real->digits=1;
        real->flags&=MPD_DATAFLAGS;
        return;
    }

    uint8_t *byte=&(atan_1_stream[atan_1_offsets[exponent]]);

    real->exp=-REAL_PRECISION_MAX-exponent;
    real->len=REAL_PRECISION_MAX/9;
    real->flags&=MPD_DATAFLAGS;
    real->digits=REAL_PRECISION_MAX;

    decompress_number(byte,atan_1_dict,real->data,real->data+REAL_PRECISION_MAX/9);

}


// RETURN ATAN(2*10^-exponent) IN real.
// REAL MUST HAVE MINIMUM (REAL_PRECISION_MAX/9) WORDS OF data PREALLOCATED

// THIS FUNCTION RELIES ON TABLES BEING GENERATED FOR THE SAME REAL_PRECISION_MAX NUMBER OF DIGITS


static void atan_2_table(int exponent,mpd_t *real)
{

    // WARNING: 1<=exponent<= digits, THIS FUNCTION DOES NOT CHECK FOR ARGUMENT RANGE

    if(exponent>REAL_PRECISION_MAX/2) {
        real->exp=-exponent;
        real->data[0]=2;
        real->len=1;
        real->digits=1;
        real->flags&=MPD_DATAFLAGS;
        return;
    }

    uint8_t *byte=&(atan_2_stream[atan_2_offsets[exponent-1]]);

    real->exp=-REAL_PRECISION_MAX-(exponent-1);
    real->len=REAL_PRECISION_MAX/9;
    real->flags&=MPD_DATAFLAGS;
    real->digits=REAL_PRECISION_MAX;

    decompress_number(byte,atan_2_dict,real->data,real->data+REAL_PRECISION_MAX/9);

}

static void atan_5_table(int exponent,mpd_t *real)
{

    // WARNING: 1<=exponent<= digits, THIS FUNCTION DOES NOT CHECK FOR ARGUMENT RANGE

    if(exponent>REAL_PRECISION_MAX/2) {
        real->exp=-exponent;
        real->data[0]=5;
        real->len=1;
        real->digits=1;
        real->flags&=MPD_DATAFLAGS;
        return;
    }

    uint8_t *byte=&(atan_5_stream[atan_5_offsets[exponent-1]]);

    real->exp=-REAL_PRECISION_MAX-(exponent-1);
    real->len=REAL_PRECISION_MAX/9;
    real->flags&=MPD_DATAFLAGS;
    real->digits=REAL_PRECISION_MAX;

    decompress_number(byte,atan_5_dict,real->data,real->data+REAL_PRECISION_MAX/9);

}

// CORDIC LOOP IN ROTATIONAL MODE

// TAKES INITIAL PARAMETERS IN RREG[0], RREG[1] AND RREG[2]
// RETURNS RESULTS IN RREG[5], RREG[6], RREG[7]

static void CORDIC_Rotational(int digits)
{
int sequence[4]={5,2,2,1};
void (*functions[4])(int,mpd_t *)={atan_5_table,atan_2_table,atan_2_table,atan_1_table};
int startidx=3;
int exponent;
uint32_t status;
mpd_t *x,*y,*z,*tmp;
mpd_t *xnext,*ynext,*znext;

// USE RReg[0]=z; RReg[1]=x; RReg[2]=y;
// THE INITIAL VALUES MUST'VE BEEN SET

// RReg[3]=S; INITIALIZED TO 1*10^0
RReg[3].len=1;
RReg[3].digits=1;
RReg[3].flags&=MPD_DATAFLAGS;

z=&RReg[0];
x=&RReg[1];
y=&RReg[2];
znext=&RReg[5];
xnext=&RReg[6];
ynext=&RReg[7];

for(exponent=0;exponent<digits;++exponent)
{
    do {
    RReg[3].exp=-exponent;
    RReg[3].data[0]=sequence[startidx];
    if(z->flags&MPD_NEG) RReg[3].flags&=~MPD_NEG;
    else RReg[3].flags|=MPD_NEG;
    mpd_qfma(xnext,&RReg[3],y,x,&Context,&status);  // x(i+1)=x(i)-S(i)*y(i)

    RReg[3].flags^=MPD_NEG;
    mpd_qfma(ynext,&RReg[3],x,y,&Context,&status);  // y(i+1)=y(i)+S(i)*x(i)

    functions[startidx](exponent,&RReg[4]);     // GET Alpha(i)
    RReg[4].flags|=z->flags&MPD_NEG;

    mpd_qsub(znext,z,&RReg[4],&Context,&status);  // z(i+1)=z(i)-Alpha(i)

    // WE FINISHED ONE STEP
    // SWAP THE POINTERS TO AVOID COPYING THE NUMBERS
    tmp=znext;
    znext=z;
    z=tmp;

    tmp=xnext;
    xnext=x;
    x=tmp;

    tmp=ynext;
    ynext=y;
    y=tmp;

    ++startidx;
    startidx&=3;
    } while(startidx);
}

// THE FINAL RESULTS ARE ALWAYS IN RREG[5], RREG[6] AND RREG[7]

// RESULTS HAVE TYPICALLY 9 DIGITS MORE THAN REQUIRED, ABOUT 6 OF THEM ARE ACCURATE
// SO ROUNDING/FINALIZING IS NEEDED
}


// CALCULATE RReg[0]=cos(angle) and RReg[1]=sin(angle) BOTH WITH 9 DIGITS MORE THAN CURRENT SYSTEM PRECISION (ABOUT 6 OF THEM ARE GOOD DIGITS, ROUNDING IS NEEDED)

void trig_sincos(mpd_t *angle)
{
    int negsin,negcos,swap;
    mpd_t pi,pi2,pi4;

    trig_PI(&pi);
    trig_PI_2(&pi2);
    trig_PI_4(&pi4);

    negcos=negsin=swap=0;
    // ALWAYS: NEED TO WORK ON PRECISION MULTIPLE OF 9
    Context.prec+=MPD_RDIGITS;

    // GET ANGLE MODULO PI
    mpd_divmod(&RReg[1],&RReg[0],angle,&pi,&Context);

    // HERE RReg[0] HAS THE REMAINDER THAT WE NEED TO WORK WITH

    // IF THE RESULT OF TEH DIVISION IS ODD, THEN WE ARE IN THE OTHER HALF OF THE CIRCLE
    if(RReg[1].data[0]&1) { negcos=negsin=1; }

    if(RReg[0].flags&MPD_NEG) { negsin^=1; RReg[0].flags&=~MPD_NEG; }

    if(mpd_cmp(&RReg[0],&pi2,&Context)==1) {
        swap=1;
        negcos^=1;
        mpd_sub(&RReg[1],&RReg[0],&pi2,&Context);
        mpd_copy(&RReg[0],&RReg[1],&Context);
    }
    if(mpd_cmp(&RReg[0],&pi4,&Context)==1) {
        swap^=1;
        mpd_sub(&RReg[1],&pi2,&RReg[0],&Context);
        mpd_copy(&RReg[0],&RReg[1],&Context);
    }


    // USE RReg[0]=z; RReg[1]=x; RReg[2]=y;

    // y=0;
    RReg[2].len=1;
    RReg[2].data[0]=0;
    RReg[2].exp=0;
    RReg[2].flags&=MPD_DATAFLAGS;
    RReg[2].digits=1;

    // x=K;
    RReg[1].len=REAL_PRECISION_MAX/MPD_RDIGITS;
    RReg[1].digits=REAL_PRECISION_MAX;
    memcpy(RReg[1].data,Constant_K1,REAL_PRECISION_MAX/MPD_RDIGITS*sizeof(uint32_t));
    RReg[1].exp=-REAL_PRECISION_MAX;
    RReg[1].flags&=MPD_DATAFLAGS;


    CORDIC_Rotational((Context.prec>REAL_PRECISION_MAX)? REAL_PRECISION_MAX:Context.prec);

    // RESTORE PREVIOUS PRECISION
    Context.prec-=MPD_RDIGITS;

    // HERE WE HAVE
    // USE RReg[5]=angle_error; RReg[6]=cos(z) RReg[7]=sin(z);

    // PUT THE cos(z) IN RReg[0]
    if(swap) {
        mpd_copy(&RReg[0],&RReg[7],&Context);
        mpd_copy(&RReg[1],&RReg[6],&Context);
    }
    else {
        mpd_copy(&RReg[1],&RReg[7],&Context);
        mpd_copy(&RReg[0],&RReg[6],&Context);
    }
    if(negcos) RReg[0].flags|=MPD_NEG;
    if(negsin) RReg[1].flags|=MPD_NEG;

}



// CORDIC LOOP IN VECTORING MODE

// TAKES INITIAL PARAMETERS IN RREG[0], RREG[1] AND RREG[2]
// RETURNS RESULTS IN RREG[5], RREG[6], RREG[7]

static void CORDIC_Vectoring(int digits)
{
int sequence[4]={5,2,2,1};
void (*functions[4])(int,mpd_t *)={atan_5_table,atan_2_table,atan_2_table,atan_1_table};
int startidx=3;
int exponent;
uint32_t status;
mpd_t *x,*y,*z,*tmp;
mpd_t *xnext,*ynext,*znext;

// USE RReg[0]=0.0; RReg[1]=x; RReg[2]=y;
// THE INITIAL VALUES MUST'VE BEEN SET

// RReg[3]=S; INITIALIZED TO 1*10^0
RReg[3].len=1;
RReg[3].digits=1;
RReg[3].flags&=MPD_DATAFLAGS;

z=&RReg[0];
x=&RReg[1];
y=&RReg[2];
znext=&RReg[5];
xnext=&RReg[6];
ynext=&RReg[7];

for(exponent=0;exponent<digits;++exponent)
{
    do {
    RReg[3].exp=-exponent;
    RReg[3].data[0]=sequence[startidx];
    if(!(y->flags&MPD_NEG)) RReg[3].flags&=~MPD_NEG;
    else RReg[3].flags|=MPD_NEG;
    mpd_qfma(xnext,&RReg[3],y,x,&Context,&status);  // x(i+1)=x(i)-S(i)*y(i)

    RReg[3].flags^=MPD_NEG;
    mpd_qfma(ynext,&RReg[3],x,y,&Context,&status);  // y(i+1)=y(i)+S(i)*x(i)

    functions[startidx](exponent,&RReg[4]);     // GET Alpha(i)
    RReg[4].flags|=y->flags&MPD_NEG;

    mpd_qadd(znext,z,&RReg[4],&Context,&status);  // z(i+1)=z(i)-Alpha(i)

    // WE FINISHED ONE STEP
    // SWAP THE POINTERS TO AVOID COPYING THE NUMBERS
    tmp=znext;
    znext=z;
    z=tmp;

    tmp=xnext;
    xnext=x;
    x=tmp;

    tmp=ynext;
    ynext=y;
    y=tmp;

    ++startidx;
    startidx&=3;
    } while(startidx);
}

// THE FINAL RESULTS ARE ALWAYS IN RREG[5], RREG[6] AND RREG[7]

// RESULTS HAVE TYPICALLY 9 DIGITS MORE THAN REQUIRED, ABOUT 6 OF THEM ARE ACCURATE
// SO ROUNDING/FINALIZING IS NEEDED
}




void trig_atan2(mpd_t *x0,mpd_t *y0)
{
// THE ONLY REQUIREMENT IS THAT y0 <= x0
int negx=x0->flags&MPD_NEG;
int negy=y0->flags&MPD_NEG;
int swap=0;

x0->flags^=negx;
y0->flags^=negy;
// ALWAYS: NEED TO WORK ON PRECISION MULTIPLE OF 9
Context.prec+=MPD_RDIGITS;

if(mpd_iszero(x0)) {
    mpd_t pi_2;
    trig_PI_2(&pi_2);
    mpd_copy(&RReg[5],&pi_2,&Context);
}
else {
    if(mpd_cmp(y0,x0,&Context)==1) {
        // NEED TO COMPUTE ATAN(X/Y) AND THEN CONVERT
        mpd_copy(&RReg[1],y0,&Context);
        mpd_copy(&RReg[2],x0,&Context);
        swap=1;
    } else {
        mpd_copy(&RReg[1],x0,&Context);
        mpd_copy(&RReg[2],y0,&Context);
    }

 // USE CORDIC TO COMPUTE
    // z = 0
    RReg[0].len=1;
    RReg[0].data[0]=0;
    RReg[0].exp=0;
    RReg[0].flags&=MPD_DATAFLAGS;
    RReg[0].digits=1;

    CORDIC_Vectoring((Context.prec>REAL_PRECISION_MAX)? REAL_PRECISION_MAX+9:Context.prec);

}


if(swap) {
    mpd_t pi_2;
    trig_PI_2(&pi_2);
    // RESULT = (PI/2 - ANGLE) FOR x0 POSITIVE
    // OR (PI/2+ANGLE) FOR x0 NEGATIVE
    if(negx) RReg[5].flags|=MPD_NEG;
    mpd_sub(&RReg[0],&pi_2,&RReg[5],&Context);
}
else {
if(negx) {
    mpd_t pi;
    trig_PI(&pi);
    // RESULT = PI - ANGLE
    mpd_sub(&RReg[0],&pi,&RReg[5],&Context);
}
else {
    mpd_copy(&RReg[0],&RReg[5],&Context);
}
}

if(negy) {
    RReg[0].flags|=MPD_NEG;
}

Context.prec-=MPD_RDIGITS;

// HERE RReg[0] CONTAINS THE ANGLE WITH 9 DIGITS MORE THAN THE CURRENT PRECISION (NONE OF THEM WILL BE ACCURATE), ROUNDING IS REQUIRED
// THE ANGLE IS IN THE RANGE -PI, +PI
// THE LAST DIGIT MIGHT BE OFF BY +/-1 WHEN USING THE MAXIMUM SYSTEM PRECISION

}




// RETURN ATANH(1*10^-exponent) IN real.
// REAL MUST HAVE MINIMUM (REAL_PRECISION_MAX/9) WORDS OF data PREALLOCATED

// THIS FUNCTION RELIES ON TABLES BEING GENERATED FOR THE SAME REAL_PRECISION_MAX NUMBER OF DIGITS

static void atanh_1_table(int exponent,mpd_t *real)
{

    // WARNING: 0<=exponent<= digits, THIS FUNCTION DOES NOT CHECK FOR ARGUMENT RANGE

    if(exponent>=REAL_PRECISION_MAX/2) {
        real->exp=-exponent;
        real->data[0]=1;
        real->len=1;
        real->digits=1;
        real->flags&=MPD_DATAFLAGS;
        return;
    }

    uint8_t *byte=&(atanh_1_stream[atanh_1_offsets[exponent-1]]);

    real->exp=-REAL_PRECISION_MAX-(exponent-1);
    real->len=REAL_PRECISION_MAX/9;
    real->flags&=MPD_DATAFLAGS;
    real->digits=REAL_PRECISION_MAX;

    decompress_number(byte,atanh_1_dict,real->data,real->data+REAL_PRECISION_MAX/9);

}


// RETURN ATANH(2*10^-exponent) IN real.
// REAL MUST HAVE MINIMUM (REAL_PRECISION_MAX/9) WORDS OF data PREALLOCATED

// THIS FUNCTION RELIES ON TABLES BEING GENERATED FOR THE SAME REAL_PRECISION_MAX NUMBER OF DIGITS


static void atanh_2_table(int exponent,mpd_t *real)
{

    // WARNING: 1<=exponent<= digits, THIS FUNCTION DOES NOT CHECK FOR ARGUMENT RANGE

    if(exponent>REAL_PRECISION_MAX/2) {
        real->exp=-exponent;
        real->data[0]=2;
        real->len=1;
        real->digits=1;
        real->flags&=MPD_DATAFLAGS;
        return;
    }

    uint8_t *byte=&(atanh_2_stream[atanh_2_offsets[exponent-1]]);

    real->exp=-REAL_PRECISION_MAX-(exponent-1);
    real->len=REAL_PRECISION_MAX/9;
    real->flags&=MPD_DATAFLAGS;
    real->digits=REAL_PRECISION_MAX;

    decompress_number(byte,atanh_2_dict,real->data,real->data+REAL_PRECISION_MAX/9);

}

static void atanh_5_table(int exponent,mpd_t *real)
{

    // WARNING: 1<=exponent<= digits, THIS FUNCTION DOES NOT CHECK FOR ARGUMENT RANGE

    if(exponent>REAL_PRECISION_MAX/2) {
        real->exp=-exponent;
        real->data[0]=5;
        real->len=1;
        real->digits=1;
        real->flags&=MPD_DATAFLAGS;
        return;
    }

    uint8_t *byte=&(atanh_5_stream[atanh_5_offsets[exponent-1]]);

    real->exp=-REAL_PRECISION_MAX-(exponent-1);
    real->len=REAL_PRECISION_MAX/9;
    real->flags&=MPD_DATAFLAGS;
    real->digits=REAL_PRECISION_MAX;

    decompress_number(byte,atanh_5_dict,real->data,real->data+REAL_PRECISION_MAX/9);

}



// CORDIC LOOP IN HYPERBOLIC ROTATIONAL MODE

// TAKES INITIAL PARAMETERS IN RREG[0], RREG[1] AND RREG[2]
// RETURNS RESULTS IN RREG[5], RREG[6], RREG[7]

static void CORDIC_Hyp_Rotational(int digits)
{
int sequence[4]={5,2,2,1};
void (*functions[4])(int,mpd_t *)={atanh_5_table,atanh_2_table,atanh_2_table,atanh_1_table};
int startidx=0;
int exponent;
uint32_t status;
mpd_t *x,*y,*z,*tmp;
mpd_t *xnext,*ynext,*znext;

// USE RReg[0]=z; RReg[1]=x; RReg[2]=y;
// THE INITIAL VALUES MUST'VE BEEN SET

// RReg[3]=S; INITIALIZED TO 1*10^0
RReg[3].len=1;
RReg[3].digits=1;
RReg[3].flags&=MPD_DATAFLAGS;

z=&RReg[0];
x=&RReg[1];
y=&RReg[2];
znext=&RReg[5];
xnext=&RReg[6];
ynext=&RReg[7];

for(exponent=1;exponent<digits;++exponent)
{
    do {
    RReg[3].exp=-exponent;
    RReg[3].data[0]=sequence[startidx];
    if(!(z->flags&MPD_NEG)) RReg[3].flags&=~MPD_NEG;
    else RReg[3].flags|=MPD_NEG;
    mpd_qfma(xnext,&RReg[3],y,x,&Context,&status);  // x(i+1)=x(i)+S(i)*y(i)

    //RReg[3].flags^=MPD_NEG;
    mpd_qfma(ynext,&RReg[3],x,y,&Context,&status);  // y(i+1)=y(i)+S(i)*x(i)

    functions[startidx](exponent,&RReg[4]);     // GET Alpha(i)
    RReg[4].flags|=z->flags&MPD_NEG;

    mpd_qsub(znext,z,&RReg[4],&Context,&status);  // z(i+1)=z(i)-Alpha(i)

    // WE FINISHED ONE STEP
    // SWAP THE POINTERS TO AVOID COPYING THE NUMBERS
    tmp=znext;
    znext=z;
    z=tmp;

    tmp=xnext;
    xnext=x;
    x=tmp;

    tmp=ynext;
    ynext=y;
    y=tmp;

    ++startidx;
    startidx&=3;
    } while(startidx);
}
// THE FINAL RESULTS ARE ALWAYS IN RREG[5], RREG[6] AND RREG[7]

// RESULTS HAVE TYPICALLY 9 DIGITS MORE THAN REQUIRED, ABOUT 6 OF THEM ARE ACCURATE
// SO ROUNDING/FINALIZING IS NEEDED
}




void hyp_exp(mpd_t *x0)
{


// TODO: RANGE REDUCTION TO +/- LN(10)/2

// ALWAYS: NEED TO WORK ON PRECISION MULTIPLE OF 9
Context.prec+=MPD_RDIGITS;

// z=x0
mpd_copy(&RReg[0],x0,&Context);

// x=y=Kh-1;
RReg[1].len=REAL_PRECISION_MAX/MPD_RDIGITS;
RReg[1].digits=REAL_PRECISION_MAX;
memcpy(RReg[1].data,Constant_Kh1,REAL_PRECISION_MAX/MPD_RDIGITS*sizeof(uint32_t));
RReg[1].exp=-(REAL_PRECISION_MAX-1);
RReg[1].flags&=MPD_DATAFLAGS;

RReg[2].len=REAL_PRECISION_MAX/MPD_RDIGITS;
RReg[2].digits=REAL_PRECISION_MAX;
memcpy(RReg[2].data,Constant_Kh1,REAL_PRECISION_MAX/MPD_RDIGITS*sizeof(uint32_t));
RReg[2].exp=-(REAL_PRECISION_MAX-1);
RReg[2].flags&=MPD_DATAFLAGS;

CORDIC_Hyp_Rotational((Context.prec>REAL_PRECISION_MAX)? REAL_PRECISION_MAX+9:Context.prec);

Context.prec-=MPD_RDIGITS;

// HERE RReg[0] CONTAINS THE ANGLE WITH 9 DIGITS MORE THAN THE CURRENT PRECISION (NONE OF THEM WILL BE ACCURATE), ROUNDING IS REQUIRED
// THE ANGLE IS IN THE RANGE -PI, +PI
// THE LAST DIGIT MIGHT BE OFF BY +/-1 WHEN USING THE MAXIMUM SYSTEM PRECISION
mpd_copy(&RReg[0],&RReg[6],&Context);
}
